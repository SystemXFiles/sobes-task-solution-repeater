# sobes-task-solution-repeater

Здесь лежит решение задачи, которую мне подкинули на собеседовании.

## Суть задачи

Нужно было написать микросервис с двумя эндпоинтами:

1. **Первый** - принимает запросы от других сервисов (уже авторизованные), печатает текст в консоль нужное число раз и
   после отдаёт 200 OK (т.е. есть удержание до момента завершения всех повторов).
   
   > **Важный момент:** между повторами печати должна быть пауза.
2. **Второй** - возвращает историю того, что напечаталось (кто, какой повтор, текст повтора).

### Что прилетает в первый эндпоинт:

* пауза между повторами (мс);
* имя пользователя;
* сколько раз повторить;
* текст сообщения.

### Технические требования:

* **Java 11**, **Spring Boot до 2.7**.
* Использовать чистый **Thread** и **несинхронизированные** коллекции.
* Прикрутить **Swagger** с описанием API на русском.
* Конфигурация пула потоков через `application.properties`.

## Как реализовано  

В обоих вариантах (ветках) логика планирования похожа:

* **Никакого активного ожидания.** Потоки честно спят ровно до момента запуска задачи. Процессор впустую не греем.
* **Общая очередь.** Пул потоков разгребает задачи сообща. Если один поток залип, остальные подхватят работу,
  производительность просядет плавно, а не колом встанет.

### Ветка `master`

То, что я написал прямо на собеседовании (live coding). Решение в лоб, потому что главное было быстро показать рабочий
прототип. Основной код лежит [здесь](src/main/java/org/example/service/RepeatService.java).

#### Как работает

Использует `CountDownLatch`, чтобы дождаться конца всех повторов. Время запуска (`startAfterTime`) считается заранее для
всех итераций.

**Преимущества:**

* Максимально просто (1 файл, а не пачка классов).

**Недостатки:**

* **Риск словить `OutOfMemory`**. Если запросить кучу повторов, они все сразу превратятся в объекты в очереди.
* **Эффект лавины**. Если сервис подвиснет, просроченные задачи начнут выполняться без пауз, создавая пиковую нагрузку.
* **Завязка на `currentTimeMillis()`**. Перевод часов на сервере может сломать планирование.
* Код свален в кучу (нарушение [**SRP**](https://en.wikipedia.org/wiki/Single-responsibility_principle)).
* **Битва потоков:**
    * При добавлении задач вызывается `signalAll`, который пробуждает все потоки и они дерутся за блокировку чтения
      очереди.
    * Все свободные потоки смотрят на первую задачу и засыпают на одно и то же время. В итоге просыпаются хором, чтобы
      подраться снова.

### Ветка `feature/another-impl`

Это уже "причесанная" версия. Тут я сделал рефакторинг, разделил ответственность и поправил узкие места.

**Преимущества:**

* **Нет жора памяти.** Задача создается один раз и переиспользуется.
* **Нет лавины.** Гибридное планирование не дает запускать задачи "задним числом".
* **Перевод часов не страшен.** Перешел на монотонный таймер `nanoTime()`.
* **Умный сон потоков.** Один дежурит у очереди, а остальные спят. Соответственно меньше деремся за блокировки и
  пропускная способность выше.
* **Чистый код.** Планировщик отдельно, бизнес-логика отдельно. Читать проще.
* Более честный порядок выполнения задач.

**Цена вопроса:**

* Кода стало больше, файлов тоже. Плата за гибкость и надежность.
